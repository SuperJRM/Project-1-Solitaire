-- Jason Rangel-Martinez
-- CMPM 121 - Solitaire Project 2
-- 5/14/25

1. Progrmming Patterns Used:
    - I used a pretty simple state pattern which determined a card's state, which then determines when they would have shadows and when they are or aren't able to be grabbed. I chose to use this pattern as it made it easy to keep each object's behavior in check, as only certain actions could be performed and only certain states could be transitioned into from any other given state.
    - I attempted to use the update method pattern, only placing parts of the code in update that needed to be updated every frame, like those dealing with the mouse's position. This was done to prevent overwhelming the code with concurrent processes each frame unneccessarily.
    - I used the prototype pattern to create clones of objects, like cards and piles, as it allowed each instance to have slight variations, like the differences between the types of piles or the states of individual cards.

2.  Feedback:
    - A lot of my feedback came from Hunter Kingsley over the course of several discussion sections. We gave each other thorough advice and usually spent the entirety of the section reading over and discussing code, to the point where he's the only person on this list. For starters, he pointed out that my main.load() was very bloated from setup and recommended I make it its own function. After going into more depth on the implementation, I came to the conclusion that not only would this improve readability, but it would also make it easier to implement a reset function into the game. He also pointed out some repeated code which made my functions a bit bloaty, which I fixed by having said code become their own functions and accepting more open-ended parameters. This is the case with a portion of code which checked if the grabber was over an object, which is now simplified into a function and no longer restricted to grabber.lua. Another big piece of advice he gave was that I should tighten my naming conventions, as some ended up being pretty confusing and unclear in terms of their purpose and what they would return, with one in prticular being the name "cardTable" for a table that held piles of cards making up the board, which I renamed to "gameTable" to better suit how it encompasses the entire game board. 
    
3.  Postmortem:
    - I like to think that I greatly improved the code overall, even if it lacks in a few areas. The biggest change from project 1 came from the complete overhaul of the grabbing system. Originally, all of my grabbing related code was in my pile.lua file, the same file which tracked the cards in each card pile. This was done by implementing numerous functions, each accepting the grabber and cardTable as parameters, meaning that the code was overall very disjointed. On top of that, it was very hard to add more features, as I'd need to track other instances of piles alongside the grabber and entire game state within a single class. Given these hurdles, my original plan to start with adding card stack movement was pushed aside pretty early on, as I quickly began running into issues coordinating every piece manually in order to make progress. Instead, I chose to completely overhaul the system, opting for a much more spread-out approach with the card grabbing code primarily implemented in grabber.lua, which makes sense intuitively. With this new implementation, the grabber only interacts with other files and objects when necessary, allowing for the code to be easily managed and updated with new features, like picking up card stacks and making each card pile distinct. I think that these efforts proved very successful overall, however, the time it took me to revamp the code meant that the final result didn't have as many new features as I would've liked. While I was able to get the card stacking, drawing, resetting, and placement exactly how I envisioned, I wasn't able to implement ranks and suits into the mix. However, given that the goal of this assignment was to teach us how to refactor our old code, I feel pretty satisfied with the work I did accomplish, as I can fully say that the both the game and code have been improved through my refactoring efforts.

4. Credits:
    - I based the code off of what was taught in lecture and during section, especially the vector.lua information.
    - All other code was made by me.
    - No external assets were used.

    